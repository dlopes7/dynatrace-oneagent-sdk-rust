/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ONESDK_XSTR_PRI_STR: &'static [u8; 2usize] = b"s\0";
pub const ONESDK_STR_PRI_XSTR: &'static [u8; 2usize] = b"s\0";
pub const ONESDK_STUB_VERSION_MAJOR: u32 = 1;
pub const ONESDK_STUB_VERSION_MINOR: u32 = 5;
pub const ONESDK_STUB_VERSION_PATCH: u32 = 1;
pub const ONESDK_LOGGING_LEVEL_FINEST: u32 = 0;
pub const ONESDK_LOGGING_LEVEL_FINER: u32 = 1;
pub const ONESDK_LOGGING_LEVEL_FINE: u32 = 2;
pub const ONESDK_LOGGING_LEVEL_CONFIG: u32 = 3;
pub const ONESDK_LOGGING_LEVEL_INFO: u32 = 4;
pub const ONESDK_LOGGING_LEVEL_WARNING: u32 = 5;
pub const ONESDK_LOGGING_LEVEL_SEVERE: u32 = 6;
pub const ONESDK_LOGGING_LEVEL_DEBUG: u32 = 7;
pub const ONESDK_LOGGING_LEVEL_NONE: u32 = 8;
pub const ONESDK_INVALID_HANDLE: u32 = 0;
pub const ONESDK_AGENT_STATE_ACTIVE: u32 = 0;
pub const ONESDK_AGENT_STATE_TEMPORARILY_INACTIVE: u32 = 1;
pub const ONESDK_AGENT_STATE_PERMANENTLY_INACTIVE: u32 = 2;
pub const ONESDK_AGENT_STATE_NOT_INITIALIZED: u32 = 3;
pub const ONESDK_AGENT_STATE_ERROR: i32 = -1;
pub const ONESDK_AGENT_FORK_STATE_PARENT_INITIALIZED: u32 = 1;
pub const ONESDK_AGENT_FORK_STATE_PRE_INITIALIZED: u32 = 2;
pub const ONESDK_AGENT_FORK_STATE_FULLY_INITIALIZED: u32 = 3;
pub const ONESDK_AGENT_FORK_STATE_NOT_FORKABLE: u32 = 4;
pub const ONESDK_AGENT_FORK_STATE_ERROR: i32 = -1;
pub const ONESDK_CHANNEL_TYPE_OTHER: u32 = 0;
pub const ONESDK_CHANNEL_TYPE_TCP_IP: u32 = 1;
pub const ONESDK_CHANNEL_TYPE_UNIX_DOMAIN_SOCKET: u32 = 2;
pub const ONESDK_CHANNEL_TYPE_NAMED_PIPE: u32 = 3;
pub const ONESDK_CHANNEL_TYPE_IN_PROCESS: u32 = 4;
pub const ONESDK_DATABASE_VENDOR_APACHE_HIVE: &'static [u8; 11usize] = b"ApacheHive\0";
pub const ONESDK_DATABASE_VENDOR_CLOUDSCAPE: &'static [u8; 11usize] = b"Cloudscape\0";
pub const ONESDK_DATABASE_VENDOR_HSQLDB: &'static [u8; 7usize] = b"HSQLDB\0";
pub const ONESDK_DATABASE_VENDOR_PROGRESS: &'static [u8; 9usize] = b"Progress\0";
pub const ONESDK_DATABASE_VENDOR_MAXDB: &'static [u8; 6usize] = b"MaxDB\0";
pub const ONESDK_DATABASE_VENDOR_HANADB: &'static [u8; 7usize] = b"HanaDB\0";
pub const ONESDK_DATABASE_VENDOR_INGRES: &'static [u8; 7usize] = b"Ingres\0";
pub const ONESDK_DATABASE_VENDOR_FIRST_SQL: &'static [u8; 9usize] = b"FirstSQL\0";
pub const ONESDK_DATABASE_VENDOR_ENTERPRISE_DB: &'static [u8; 13usize] = b"EnterpriseDB\0";
pub const ONESDK_DATABASE_VENDOR_CACHE: &'static [u8; 6usize] = b"Cache\0";
pub const ONESDK_DATABASE_VENDOR_ADABAS: &'static [u8; 7usize] = b"Adabas\0";
pub const ONESDK_DATABASE_VENDOR_FIREBIRD: &'static [u8; 9usize] = b"Firebird\0";
pub const ONESDK_DATABASE_VENDOR_DB2: &'static [u8; 4usize] = b"DB2\0";
pub const ONESDK_DATABASE_VENDOR_DERBY_CLIENT: &'static [u8; 13usize] = b"Derby Client\0";
pub const ONESDK_DATABASE_VENDOR_DERBY_EMBEDDED: &'static [u8; 15usize] = b"Derby Embedded\0";
pub const ONESDK_DATABASE_VENDOR_FILEMAKER: &'static [u8; 10usize] = b"Filemaker\0";
pub const ONESDK_DATABASE_VENDOR_INFORMIX: &'static [u8; 9usize] = b"Informix\0";
pub const ONESDK_DATABASE_VENDOR_INSTANT_DB: &'static [u8; 10usize] = b"InstantDb\0";
pub const ONESDK_DATABASE_VENDOR_INTERBASE: &'static [u8; 10usize] = b"Interbase\0";
pub const ONESDK_DATABASE_VENDOR_MYSQL: &'static [u8; 6usize] = b"MySQL\0";
pub const ONESDK_DATABASE_VENDOR_MARIADB: &'static [u8; 8usize] = b"MariaDB\0";
pub const ONESDK_DATABASE_VENDOR_NETEZZA: &'static [u8; 8usize] = b"Netezza\0";
pub const ONESDK_DATABASE_VENDOR_ORACLE: &'static [u8; 7usize] = b"Oracle\0";
pub const ONESDK_DATABASE_VENDOR_PERVASIVE: &'static [u8; 10usize] = b"Pervasive\0";
pub const ONESDK_DATABASE_VENDOR_POINTBASE: &'static [u8; 10usize] = b"Pointbase\0";
pub const ONESDK_DATABASE_VENDOR_POSTGRESQL: &'static [u8; 11usize] = b"PostgreSQL\0";
pub const ONESDK_DATABASE_VENDOR_SQLSERVER: &'static [u8; 11usize] = b"SQL Server\0";
pub const ONESDK_DATABASE_VENDOR_SQLITE: &'static [u8; 7usize] = b"sqlite\0";
pub const ONESDK_DATABASE_VENDOR_SYBASE: &'static [u8; 7usize] = b"Sybase\0";
pub const ONESDK_DATABASE_VENDOR_TERADATA: &'static [u8; 9usize] = b"Teradata\0";
pub const ONESDK_DATABASE_VENDOR_VERTICA: &'static [u8; 8usize] = b"Vertica\0";
pub const ONESDK_DATABASE_VENDOR_CASSANDRA: &'static [u8; 10usize] = b"Cassandra\0";
pub const ONESDK_DATABASE_VENDOR_H2: &'static [u8; 3usize] = b"H2\0";
pub const ONESDK_DATABASE_VENDOR_COLDFUSION_IMQ: &'static [u8; 15usize] = b"ColdFusion IMQ\0";
pub const ONESDK_DATABASE_VENDOR_REDSHIFT: &'static [u8; 16usize] = b"Amazon Redshift\0";
pub const ONESDK_DATABASE_VENDOR_COUCHBASE: &'static [u8; 10usize] = b"Couchbase\0";
pub const ONESDK_DYNATRACE_HTTP_HEADER_NAME: &'static [u8; 12usize] = b"X-dynaTrace\0";
pub const ONESDK_DYNATRACE_MESSAGE_PROPERTY_NAME: &'static [u8; 16usize] = b"dtdTraceTagInfo\0";
pub const ONESDK_DYNATRACE_MESSAGE_PROPERTYNAME: &'static [u8; 16usize] = b"dtdTraceTagInfo\0";
pub const ONESDK_MESSAGING_DESTINATION_TYPE_QUEUE: u32 = 1;
pub const ONESDK_MESSAGING_DESTINATION_TYPE_TOPIC: u32 = 2;
pub const ONESDK_MESSAGING_VENDOR_HORNETQ: &'static [u8; 8usize] = b"HornetQ\0";
pub const ONESDK_MESSAGING_VENDOR_ACTIVE_MQ: &'static [u8; 9usize] = b"ActiveMQ\0";
pub const ONESDK_MESSAGING_VENDOR_RABBIT_MQ: &'static [u8; 9usize] = b"RabbitMQ\0";
pub const ONESDK_MESSAGING_VENDOR_ARTEMIS: &'static [u8; 8usize] = b"Artemis\0";
pub const ONESDK_MESSAGING_VENDOR_WEBSPHERE: &'static [u8; 10usize] = b"WebSphere\0";
pub const ONESDK_MESSAGING_VENDOR_MQSERIES_JMS: &'static [u8; 13usize] = b"MQSeries JMS\0";
pub const ONESDK_MESSAGING_VENDOR_MQSERIES: &'static [u8; 9usize] = b"MQSeries\0";
pub const ONESDK_MESSAGING_VENDOR_TIBCO: &'static [u8; 6usize] = b"Tibco\0";
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type onesdk_result_t = i32;
#[doc = " @name Integer Types"]
#[doc = "@{"]
#[doc = "@anchor integer_types"]
pub type onesdk_bool_t = i32;
pub type onesdk_int32_t = i32;
pub type onesdk_int64_t = i64;
pub type onesdk_uint32_t = u32;
pub type onesdk_uint64_t = u64;
pub type onesdk_size_t = size_t;
pub type onesdk_xchar_t = ::std::os::raw::c_char;
#[doc = " @brief Stores the stub version number."]
#[doc = "@see @ref onesdk_stub_get_version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onesdk_stub_version {
    #[doc = "< @brief ONESDK_STUB_VERSION_MAJOR"]
    pub version_major: onesdk_uint32_t,
    #[doc = "< @brief ONESDK_STUB_VERSION_MINOR"]
    pub version_minor: onesdk_uint32_t,
    #[doc = "< @brief ONESDK_STUB_VERSION_PATCH"]
    pub version_patch: onesdk_uint32_t,
}
#[test]
fn bindgen_test_layout_onesdk_stub_version() {
    assert_eq!(
        ::std::mem::size_of::<onesdk_stub_version>(),
        12usize,
        concat!("Size of: ", stringify!(onesdk_stub_version))
    );
    assert_eq!(
        ::std::mem::align_of::<onesdk_stub_version>(),
        4usize,
        concat!("Alignment of ", stringify!(onesdk_stub_version))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<onesdk_stub_version>())).version_major as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(onesdk_stub_version),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<onesdk_stub_version>())).version_minor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(onesdk_stub_version),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<onesdk_stub_version>())).version_patch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(onesdk_stub_version),
            "::",
            stringify!(version_patch)
        )
    );
}
pub type onesdk_stub_version_t = onesdk_stub_version;
#[doc = " @brief Agent logging function prototype."]
#[doc = "@param message      The message."]
#[doc = ""]
#[doc = "On Windows, the message is UTF-8 encoded. On other platforms, the message uses the system default encoding."]
#[doc = ""]
#[doc = "Applications should not try to parse or interpret the message or in any way rely on the wording/format of the message."]
#[doc = ""]
#[doc = "@see @ref onesdk_agent_set_logging_callback"]
pub type onesdk_agent_logging_callback_t =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
#[doc = " @brief Integer type for logging levels."]
#[doc = "@see @ref logging_level_constants"]
pub type onesdk_logging_level_t = onesdk_int32_t;
#[doc = " @brief Type for all SDK handles."]
#[doc = ""]
#[doc = "The \"derived\" typedefs are solely used for the purpose of documentation."]
pub type onesdk_handle_t = onesdk_uint64_t;
pub type onesdk_tracer_handle_t = onesdk_handle_t;
pub type onesdk_databaseinfo_handle_t = onesdk_handle_t;
pub type onesdk_webapplicationinfo_handle_t = onesdk_handle_t;
pub type onesdk_messagingsysteminfo_handle_t = onesdk_handle_t;
#[doc = " @ingroup ex_metrics */"]
pub type onesdk_metric_handle_t = onesdk_handle_t;
extern "C" {
    #[doc = " @brief Retrieves the stub version number."]
    #[doc = "@param[out] out_stub_version    Pointer to a @ref onesdk_stub_version_t struct that will be filled with the stub version number."]
    #[doc = ""]
    #[doc = "An application can use this function to make sure the stub binary matches the header files that were used to compile the application."]
    #[doc = "Especially useful when using the shared stub version (DLL/SO)."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.2.0."]
    pub fn onesdk_stub_get_version(out_stub_version: *mut onesdk_stub_version_t);
}
extern "C" {
    #[doc = " @brief Retrieves a human readable error message corresponding to an error code that was returned by the SDK stub."]
    #[doc = "@param error_code       An error code returned by an SDK stub function."]
    #[doc = "@param[out] buffer      Pointer to a buffer into which the error message shall be copied."]
    #[doc = "@param buffer_length    The length of the buffer pointed to by @p buffer in @ref onesdk_xchar_t characters."]
    #[doc = ""]
    #[doc = "@return @p buffer"]
    #[doc = ""]
    #[doc = "If @p buffer_length is at least one, this function will make sure that the string copied to @p buffer is always null-terminated."]
    #[doc = "If the provided buffer is too small, the error message will be truncated."]
    pub fn onesdk_stub_xstrerror(
        error_code: onesdk_result_t,
        buffer: *mut onesdk_xchar_t,
        buffer_length: onesdk_size_t,
    ) -> *const onesdk_xchar_t;
}
extern "C" {
    #[doc = " @brief Determines whether a command line argument is an SDK argument."]
    #[doc = "@param arg      A command line argument."]
    #[doc = ""]
    #[doc = "@return A non-zero value if @p arg starts with `--dt_`, zero otherwise."]
    pub fn onesdk_stub_is_sdk_cmdline_arg(arg: *const onesdk_xchar_t) -> onesdk_bool_t;
}
extern "C" {
    #[doc = " @brief Processes one command line argument."]
    #[doc = "@param arg                  A command line argument."]
    #[doc = "@param replace_existing     Tells the function whether it should overwrite an existing value (non-zero) or not (zero)."]
    #[doc = ""]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- If @p arg is an SDK command line argument with invalid format (e.g. not in the form `key=value`) this function will return"]
    #[doc = "@ref ONESDK_ERROR_INVALID_ARGUMENT."]
    #[doc = "- If @p arg is an SDK command line argument with a key for which a value has already been set and @p replace_existing is zero this"]
    #[doc = "function will return @ref ONESDK_ERROR_ENTRY_ALREADY_EXISTS."]
    #[doc = ""]
    #[doc = "If @p arg is an SDK command line argument, this function will store the `key=value` pair defined by that argument."]
    #[doc = "If called with @p arg set to `NULL` or a string that isn't an SDK command line arguments this function will do nothing and return"]
    #[doc = "@ref ONESDK_SUCCESS."]
    pub fn onesdk_stub_process_cmdline_arg(
        arg: *const onesdk_xchar_t,
        replace_existing: onesdk_bool_t,
    ) -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Processes multiple command line arguments."]
    #[doc = "@param argc                 The number of entries in @p argv."]
    #[doc = "@param argv                 Points to an array of pointers to command line argument strings."]
    #[doc = "@param replace_existing     Tells the function whether it should overwrite existing values (non-zero) or not (zero)."]
    #[doc = ""]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK error code otherwise."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- If one of the processed strings is an SDK command line argument with invalid format this function will return"]
    #[doc = "@ref ONESDK_ERROR_INVALID_ARGUMENT."]
    #[doc = "- If one of the processed strings was an SDK command line argument with a key for which a value has already been set,"]
    #[doc = "@p replace_existing is zero and no other error occurred, this function will return @ref ONESDK_ERROR_ENTRY_ALREADY_EXISTS."]
    #[doc = ""]
    #[doc = "This function will process the arguments `argv[1]` ... `argv[argc - 1]` as if by calling `onesdk_stub_process_cmdline_arg(argv[i])`."]
    #[doc = "`argv[0]` is ignored. That means it's possible to call it with the `argc` and `argv` arguments of a typical C `main` function."]
    #[doc = "Neither @p argc or @p argv will be modified."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_stub_process_cmdline_arg"]
    #[doc = "@see @ref onesdk_stub_strip_sdk_cmdline_args"]
    pub fn onesdk_stub_process_cmdline_args(
        argc: ::std::os::raw::c_int,
        argv: *const *const onesdk_xchar_t,
        replace_existing: onesdk_bool_t,
    ) -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Removes SDK command line arguments from an `argv` array."]
    #[doc = "@param[in,out] argc     Points to an `int` which specifies the number of entries in @p argv."]
    #[doc = "@param[in,out] argv     Points to an array of pointers to command line argument strings."]
    #[doc = ""]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "This function modifies the array pointed to by @p argv by removing entries that are SDK command line arguments. `argv[0]` is ignored."]
    #[doc = "The value pointed to by @p argc is then updated to reflect the new array size."]
    pub fn onesdk_stub_strip_sdk_cmdline_args(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut onesdk_xchar_t,
    ) -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Sets an SDK initialization variable."]
    #[doc = "@param var                  A string with an SDK initialization variable definition in the form `key=value`."]
    #[doc = "@param replace_existing     Tells the function whether it should overwrite an existing value (non-zero) or not (zero)."]
    #[doc = ""]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- If @p var is `NULL` or points to an empty string this function will do nothing and return @ref ONESDK_SUCCESS."]
    #[doc = "- If @p var has an invalid format this function will return @ref ONESDK_ERROR_INVALID_ARGUMENT."]
    #[doc = "- If @p var defines a variable with a key for which a value has already been set and @p replace_existing is zero this function will"]
    #[doc = "return @ref ONESDK_ERROR_ENTRY_ALREADY_EXISTS."]
    pub fn onesdk_stub_set_variable(
        var: *const onesdk_xchar_t,
        replace_existing: onesdk_bool_t,
    ) -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Clears all SDK initialization variables."]
    #[doc = ""]
    #[doc = "This function clears all SDK initialization variables and releases the memory used to store them."]
    pub fn onesdk_stub_free_variables();
}
#[doc = " @brief SDK stub logging function prototype."]
#[doc = "@param level        The logging level of the message. See @ref logging_level_constants."]
#[doc = "@param message      The undecorated log message."]
#[doc = ""]
#[doc = "@note Messages which do not pass the logging level test (see @ref onesdk_stub_set_logging_level) will not be forwarded to the logging"]
#[doc = "function."]
#[doc = ""]
#[doc = "@note The message string will not contain any decoration as described in @ref onesdk_stub_default_logging_function."]
pub type onesdk_stub_logging_callback_t = ::std::option::Option<
    unsafe extern "C" fn(level: onesdk_logging_level_t, message: *const onesdk_xchar_t),
>;
extern "C" {
    #[doc = " @brief The default SDK stub logging function - writes to `stderr`."]
    #[doc = "@param level        See @ref onesdk_stub_logging_callback_t."]
    #[doc = "@param message      See @ref onesdk_stub_logging_callback_t."]
    #[doc = ""]
    #[doc = "This function will decorate the log message with the following items:"]
    #[doc = "- The current date and time (UTC)"]
    #[doc = "- An identifier for the current thread"]
    #[doc = "- The string representation of the message's logging level"]
    #[doc = "- The string \"[onesdk]\" to mark the log output as coming from the SDK stub"]
    #[doc = "- A trailing newline character"]
    #[doc = ""]
    #[doc = "The resulting string will the be written to `stderr`."]
    #[doc = ""]
    #[doc = "An application can"]
    #[doc = "- Set this function using @ref onesdk_stub_set_logging_callback to restore the default or"]
    #[doc = "- Call this function from its own logging function (e.g. to filter log messages or forward them to some other place in addition to"]
    #[doc = "writing them to `stderr`)."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_stub_set_logging_callback"]
    pub fn onesdk_stub_default_logging_function(
        level: onesdk_logging_level_t,
        message: *const onesdk_xchar_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the SDK stub logging level."]
    #[doc = "@param level        The new SDK stub logging level."]
    #[doc = ""]
    #[doc = "The default SDK stub logging level is @ref ONESDK_LOGGING_LEVEL_NONE which means no messages will be logged."]
    #[doc = "Messages with a level < the current SDK stub logging level will be suppressed (=not sent to the logging function)."]
    #[doc = ""]
    #[doc = "@note This only affects log messages generated in the SDK stub itself. The actual agent uses a different logging mechanism."]
    #[doc = ""]
    #[doc = "@see @ref logging_level_constants"]
    #[doc = "@see @ref onesdk_stub_set_logging_callback"]
    pub fn onesdk_stub_set_logging_level(level: onesdk_logging_level_t);
}
extern "C" {
    #[doc = " @brief Sets the SDK stub logging callback function."]
    #[doc = "@param stub_logging_callback     The new SDK stub logging callback function."]
    #[doc = ""]
    #[doc = "The stub logging callback function is used to log messages while initializing (locating and loading the agent) and shutting down the"]
    #[doc = "SDK (unloading the agent)."]
    #[doc = ""]
    #[doc = "The default logging function is @ref onesdk_stub_default_logging_function."]
    #[doc = ""]
    #[doc = "An application can use this function to change how SDK stub log messages are formatted and where they're written to."]
    #[doc = ""]
    #[doc = "If @p stub_logging_callback is set to `NULL`, all log messages will be discarded."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_stub_logging_callback_t"]
    #[doc = "@see @ref onesdk_stub_default_logging_function"]
    #[doc = "@see @ref onesdk_agent_set_logging_callback"]
    pub fn onesdk_stub_set_logging_callback(stub_logging_callback: onesdk_stub_logging_callback_t);
}
extern "C" {
    #[doc = " @brief Load and initialize the SDK agent."]
    #[doc = ""]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "This function tries to locate, load and initialize the SDK agent. See @ref onesdk_shutdown for shutting down and unloading"]
    #[doc = "the agent. If this function is called after the agent has already been initialized, an internal reference count will be incremented."]
    #[doc = "In that case the application must call @ref onesdk_shutdown once for each successful call to @ref onesdk_initialize."]
    #[doc = ""]
    #[doc = "This function behaves just as `onesdk_initialize_2(0)`."]
    #[doc = ""]
    #[doc = "@note If your application forks while executing @ref onesdk_initialize, @ref onesdk_initialize_2 or @ref onesdk_shutdownonesdk_shutdown on another"]
    #[doc = "thread, it is not safe to call SDK functions in the forked child process without calling `exec` first. Doing so may result in a"]
    #[doc = "deadlock."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_initialize_2"]
    #[doc = "@see @ref onesdk_stub_get_agent_load_info can give more information about initialization failures."]
    pub fn onesdk_initialize() -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Load and initialize the SDK agent, with additional flags."]
    #[doc = "@param init_flags   A bitwise combination of flags from @ref init_flags or zero."]
    #[doc = ""]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "This function tries to locate, load and initialize the SDK agent. See @ref onesdk_shutdown for shutting down and unloading"]
    #[doc = "the agent. If this function is called after the agent has already been initialized, an internal reference count will be incremented."]
    #[doc = "In that case the application must call @ref onesdk_shutdown once for each successful call to @ref onesdk_initialize."]
    #[doc = ""]
    #[doc = "@note If your application forks while executing @ref onesdk_initialize, @ref onesdk_initialize_2 or @ref onesdk_shutdown on another"]
    #[doc = "thread, it is not safe to call SDK functions in the forked child process without calling `exec` first. Doing so may result in a"]
    #[doc = "deadlock. (This restriction also applies when using @ref ONESDK_INIT_FLAG_FORKABLE.)"]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.3.0."]
    #[doc = ""]
    #[doc = "@see @ref init_flags"]
    #[doc = "@see @ref onesdk_initialize"]
    #[doc = "@see @ref onesdk_stub_get_agent_load_info can give more information about initialization failures."]
    pub fn onesdk_initialize_2(init_flags: onesdk_uint32_t) -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Shut down and unload the SDK agent."]
    #[doc = ""]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "This function will shut down and unload the SDK agent."]
    #[doc = ""]
    #[doc = "@note If your application forks while executing @ref onesdk_initialize, @ref onesdk_initialize_2 or @ref onesdk_shutdown on another"]
    #[doc = "thread, it is not safe to call SDK functions in the forked child process without calling `exec` first. Doing so may result in a"]
    #[doc = "deadlock."]
    #[doc = "@note Unloading the actual SDK agent module (DLL/SO/...) may not be possible on all platforms."]
    pub fn onesdk_shutdown() -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Retrieves debug information about the currently used agent."]
    #[doc = "@param[out] agent_found      [optional] Pointer to a bool indicating whether the agent was found or not."]
    #[doc = "@param[out] agent_compatible [optional] Pointer to a bool indicating whether the agent was both found and compatible or not."]
    #[doc = ""]
    #[doc = "This function only yields meaningful results between calling @ref onesdk_initialize (or @ref onesdk_initialize_2) and"]
    #[doc = "@ref onesdk_shutdown. It is useful to get more information about why initialization failed. Sucessful initialization always implies"]
    #[doc = "that both @p *agent_found and @p *agent_compatible are true."]
    #[doc = ""]
    #[doc = "Note that @p *agent_found is also false if initialization failed before even trying to find the agent and"]
    #[doc = "@p *agent_compatible is also false if the agent was found but its compatibility could not be checked."]
    #[doc = "@see @ref onesdk_agent_get_version_string may have the version of the agent, which is interesting if"]
    #[doc = "@p *agent_found is true but @p *agent_compatible is not."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.3.0."]
    pub fn onesdk_stub_get_agent_load_info(
        agent_found: *mut onesdk_bool_t,
        agent_compatible: *mut onesdk_bool_t,
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " @brief Used to store CCSID values."]
pub type onesdk_ccsid_t = u16;
#[doc = " @brief Represents a reference to string data in a user specified encoding."]
#[doc = ""]
#[doc = "For normal (non-null, non-empty) strings, simply set #data to point to the string data, #byte_length to the length of the string data"]
#[doc = "in bytes and #ccsid to the CCSID value for the used encoding."]
#[doc = ""]
#[doc = "For an empty string, set #byte_length to zero and #ccsid to any valid, supported CCSID value (i.e. _not_ @ref ONESDK_CCSID_NULL)."]
#[doc = ""]
#[doc = "If you set #byte_length to zero and #ccsid to @ref ONESDK_CCSID_NULL, the SDK will interpret this as a \"null string\"."]
#[doc = "To use @ref ONESDK_CCSID_NULL together with a non-zero length is an error."]
#[doc = ""]
#[doc = "When calling a function that takes a @ref onesdk_string_t pointer argument, you can also pass a NULL pointer to specify"]
#[doc = "a \"null string\"."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onesdk_string {
    #[doc = "< @brief Pointer to the beginning of the string data. May be `NULL` if #byte_length is zero."]
    pub data: *const ::std::os::raw::c_void,
    #[doc = "< @brief The length of the buffer pointed to by #data, in bytes."]
    pub byte_length: onesdk_size_t,
    #[doc = "< @brief Specifies the encoding of the string data."]
    pub ccsid: onesdk_ccsid_t,
}
#[test]
fn bindgen_test_layout_onesdk_string() {
    assert_eq!(
        ::std::mem::size_of::<onesdk_string>(),
        24usize,
        concat!("Size of: ", stringify!(onesdk_string))
    );
    assert_eq!(
        ::std::mem::align_of::<onesdk_string>(),
        8usize,
        concat!("Alignment of ", stringify!(onesdk_string))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<onesdk_string>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(onesdk_string),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<onesdk_string>())).byte_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(onesdk_string),
            "::",
            stringify!(byte_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<onesdk_string>())).ccsid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(onesdk_string),
            "::",
            stringify!(ccsid)
        )
    );
}
pub type onesdk_string_t = onesdk_string;
extern "C" {
    #[doc = " @brief Returns the version string of the loaded SDK agent module."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "A pointer to a null-terminated @ref onesdk_xchar_t string constant that indicates the version of the loaded SDK agent module."]
    #[doc = "May also contain the version of the module that was last attempted to load if the last SDK initialization failed but the agent"]
    #[doc = "version could still be determined."]
    #[doc = "If the agent has not been initialized yet or its version could not be determined, this function will return an empty string."]
    #[doc = ""]
    #[doc = "Your application should not try to parse the version string or make any assumptions about its format."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_stub_get_agent_load_info can be used to query if a compatible agent was found."]
    pub fn onesdk_agent_get_version_string() -> *const onesdk_xchar_t;
}
extern "C" {
    #[doc = " @brief Returns the current agent state."]
    #[doc = ""]
    #[doc = "@return The current agent state."]
    #[doc = ""]
    #[doc = "@see @ref agent_state_constants \"Agent state constants\""]
    pub fn onesdk_agent_get_current_state() -> onesdk_int32_t;
}
extern "C" {
    #[doc = " @brief DEPRECATED. Sets the agent warning callback function."]
    #[doc = "@param agent_logging_callback   The new agent warning callback function."]
    #[doc = ""]
    #[doc = "@deprecated From 1.5 on, use @ref onesdk_agent_set_warning_callback instead, which has a return code but is otherwise the same"]
    #[doc = "(@c onesdk_agent_set_logging_callback, like @ref onesdk_agent_set_warning_callback, can fail but it has no way to report errors)."]
    pub fn onesdk_agent_set_logging_callback(
        agent_logging_callback: onesdk_agent_logging_callback_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the agent warning callback function."]
    #[doc = "@param agent_logging_callback   The new agent warning callback function."]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "The agent warning callback is called whenever one of the following happens while executing an SDK function:"]
    #[doc = "- An SDK usage error is detected or"]
    #[doc = "- An unexpected or unusual event (e.g. out of memory) prevented an operation from completing successfully."]
    #[doc = ""]
    #[doc = "The agent warning callback is only ever called from SDK functions (i.e., it can only be invoked on threads"]
    #[doc = "that call SDK functions, while the SDK function is executing). The application must not call any SDK functions"]
    #[doc = "from the callback."]
    #[doc = ""]
    #[doc = "This mechanism is provided primarily as a development and debugging aid. Typically, you should set it once, right after initializing"]
    #[doc = "the SDK and never change it (though changing the callback is supported, it rarely makes sense)."]
    #[doc = ""]
    #[doc = "There is no default logging function."]
    #[doc = ""]
    #[doc = "@note This function requires that the SDK is initialized (using @ref onesdk_initialize or @ref onesdk_initialize_2)."]
    #[doc = "@see @ref onesdk_agent_logging_callback_t"]
    #[doc = "@see @ref onesdk_stub_set_logging_callback sets the callback that is used for logging before and while the agent is loaded."]
    #[doc = "@since This function was added in version 1.5.0, as a replacement for @ref onesdk_agent_set_logging_callback."]
    pub fn onesdk_agent_set_warning_callback(
        agent_logging_callback: onesdk_agent_logging_callback_t,
    ) -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Sets the verbose agent logging callback function."]
    #[doc = "@param agent_logging_callback   The new verbose agent logging callback function."]
    #[doc = "@return @ref ONESDK_SUCCESS if successful, an SDK stub error code otherwise."]
    #[doc = ""]
    #[doc = "Similar to @ref onesdk_agent_set_warning_callback but the callback supplied here will not be called with warning messages"]
    #[doc = "but with additional messages that may e.g. explain why a PurePath was not created even if the reason is (usually) benign."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "- It usually does not make sense to set this callback without also using @ref onesdk_agent_set_warning_callback in addition."]
    #[doc = "- This function requires that the SDK is initialized (using @ref onesdk_initialize or @ref onesdk_initialize_2)."]
    #[doc = "@warning This callback can receive lots and lots of messages. You should not usually use it in production."]
    #[doc = "@since This function was added in version 1.5.0."]
    pub fn onesdk_agent_set_verbose_callback(
        agent_logging_callback: onesdk_agent_logging_callback_t,
    ) -> onesdk_result_t;
}
extern "C" {
    #[doc = " @brief Returns the current agent fork state. Only relevant if you used @ref ONESDK_INIT_FLAG_FORKABLE. See @ref agent_fork_state_constants \"Agent forking state constants\"."]
    #[doc = ""]
    #[doc = "Calling this function only has a defined result when @ref onesdk_agent_get_current_state returns @ref ONESDK_AGENT_STATE_ACTIVE or"]
    #[doc = "@ref ONESDK_AGENT_STATE_TEMPORARILY_INACTIVE."]
    #[doc = ""]
    #[doc = "@return The current agent fork state, i.e., one of the @ref agent_fork_state_constants."]
    #[doc = "@see @ref agent_fork_state_constants \"Agent forking state constants\""]
    pub fn onesdk_agent_get_fork_state() -> onesdk_int32_t;
}
extern "C" {
    #[doc = " @brief Starts a tracer."]
    #[doc = "@param tracer_handle    A valid tracer handle."]
    #[doc = ""]
    #[doc = "Starts the specified tracer. This will capture all entry fields of the tracer and start the time measurement."]
    pub fn onesdk_tracer_start(tracer_handle: onesdk_tracer_handle_t);
}
extern "C" {
    #[doc = " @brief Ends and releases a tracer."]
    #[doc = "@param tracer_handle    A valid tracer handle."]
    #[doc = ""]
    #[doc = "This function releases the specified tracer. Allocated resources are freed and the handle is invalidated."]
    #[doc = ""]
    #[doc = "An application should call @ref onesdk_tracer_start exactly once for each tracer that it has created."]
    #[doc = ""]
    #[doc = "If the tracer has been started, the time measurement will be stopped and its exit fields will be captured before releasing the tracer."]
    #[doc = ""]
    #[doc = "@note Just like all other tracer functions, this function must only be called from the thread that was used to create the tracer."]
    #[doc = "This is important because it means that a tracer cannot be released on a different thread. Attempting to do so is an error and"]
    #[doc = "will result in memory leaks."]
    pub fn onesdk_tracer_end(tracer_handle: onesdk_tracer_handle_t);
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_tracer_error_p(
        tracer_handle: onesdk_tracer_handle_t,
        error_class: *const onesdk_string_t,
        error_message: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the string representation of the tag from an \"outgoing taggable\" tracer."]
    #[doc = "@param tracer_handle                A valid tracer handle."]
    #[doc = "@param[out] buffer                  [optional] Pointer to a buffer into which the string representation shall be copied."]
    #[doc = "@param buffer_size                  Size of the buffer pointed to by @p buffer in bytes. Must be zero if @p buffer is `NULL`."]
    #[doc = "@param[out] required_buffer_size    [optional] Pointer to a @ref onesdk_size_t variable where the required buffer size will be stored."]
    #[doc = ""]
    #[doc = "@return The number of characters copied into @p buffer, not including the terminating null character."]
    #[doc = ""]
    #[doc = "An application can call this function to retrieve the string representation of the outgoing tag for a tracer. The tracer handle"]
    #[doc = "must refer to an \"outgoing taggable\" tracer that has already been started."]
    #[doc = ""]
    #[doc = "If @p required_buffer_size is not `NULL`, the number of bytes required to store the string representation is stored in"]
    #[doc = "@p *required_buffer_size."]
    #[doc = ""]
    #[doc = "If @p buffer is not `NULL` and @p buffer_size is big enough, this function will copy the string representation into the provided buffer."]
    #[doc = ""]
    #[doc = "This function will always make sure that, if the application provides a non-`NULL` @p buffer with a @p buffer_size >= 1, @p buffer will"]
    #[doc = "always be null-terminated. I.e. if the string representation cannot be stored because @p buffer_size is too small, a null character will"]
    #[doc = "be written into @p buffer[0]."]
    #[doc = ""]
    #[doc = "The string copied into @p buffer uses ASCII encoding."]
    #[doc = ""]
    #[doc = "@note If called with invalid arguments, the retrieved string will be an empty string."]
    #[doc = "@note Calling this function multiple times for the same tracer is explicitly supported and will yield the same result."]
    #[doc = "@note Retrieving both the string representation and the binary representation from the same tracer is explicitly supported."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_tracer_get_outgoing_dynatrace_byte_tag"]
    pub fn onesdk_tracer_get_outgoing_dynatrace_string_tag(
        tracer_handle: onesdk_tracer_handle_t,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: onesdk_size_t,
        required_buffer_size: *mut onesdk_size_t,
    ) -> onesdk_size_t;
}
extern "C" {
    #[doc = " @brief Retrieves the binary representation of the tag from an \"outgoing taggable\" tracer."]
    #[doc = "@param tracer_handle                A valid tracer handle."]
    #[doc = "@param[out] buffer                  [optional] Pointer to a buffer into which the binary representation shall be copied."]
    #[doc = "@param buffer_size                  Size of the buffer pointed to by @p buffer in bytes. Must be zero if @p buffer is `NULL`."]
    #[doc = "@param[out] required_buffer_size    [optional] Pointer to a @ref onesdk_size_t variable where the required buffer size will be stored."]
    #[doc = ""]
    #[doc = "@return The number of bytes copied into @p buffer."]
    #[doc = ""]
    #[doc = "An application can call this function to retrieve the binary representation of the outgoing tag for a tracer. The tracer handle"]
    #[doc = "must refer to an \"outgoing taggable\" tracer that has already been started."]
    #[doc = ""]
    #[doc = "If @p required_buffer_size is not `NULL`, the number of bytes required to store the binary representation is stored in"]
    #[doc = "@p *required_buffer_size."]
    #[doc = ""]
    #[doc = "If @p buffer is not `NULL` and @p buffer_size is big enough, this function will copy the binary representation into the provided buffer."]
    #[doc = ""]
    #[doc = "@note If called with invalid arguments, the retrieved binary tag will be empty (have zero length)."]
    #[doc = "@note Calling this function multiple times for the same tracer is explicitly supported and will yield the same result."]
    #[doc = "@note Retrieving both the string representation and the binary representation from the same tracer is explicitly supported."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_tracer_get_outgoing_dynatrace_string_tag"]
    pub fn onesdk_tracer_get_outgoing_dynatrace_byte_tag(
        tracer_handle: onesdk_tracer_handle_t,
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: onesdk_size_t,
        required_buffer_size: *mut onesdk_size_t,
    ) -> onesdk_size_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_tracer_set_incoming_dynatrace_string_tag_p(
        tracer_handle: onesdk_tracer_handle_t,
        string_tag: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the tag of an \"incoming taggable\" tracer using the binary representation."]
    #[doc = "@param tracer_handle    A valid tracer handle."]
    #[doc = "@param byte_tag         Pointer to an array that holds the binary representation of the incoming tag."]
    #[doc = "@param byte_tag_size    Size of the binary representation of the incoming tag."]
    #[doc = ""]
    #[doc = "An application can call this function to set the incoming tag of an \"incoming taggable\" tracer using the binary representation."]
    #[doc = "The tracer handle must refer to an \"incoming taggable\" tracer that has not been started yet."]
    #[doc = ""]
    #[doc = "If @p byte_tag_size is zero, the incoming tag will be reset (cleared)."]
    #[doc = ""]
    #[doc = "@note An \"incoming taggable\" tracer has _one_ tag. Calling @ref onesdk_tracer_set_incoming_dynatrace_byte_tag will overwrite any tag"]
    #[doc = "that was set by either @ref onesdk_tracer_set_incoming_dynatrace_string_tag or @ref onesdk_tracer_set_incoming_dynatrace_byte_tag."]
    #[doc = ""]
    #[doc = "@see @ref onesdk_tracer_set_incoming_dynatrace_string_tag"]
    pub fn onesdk_tracer_set_incoming_dynatrace_byte_tag(
        tracer_handle: onesdk_tracer_handle_t,
        byte_tag: *const ::std::os::raw::c_uchar,
        byte_tag_size: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_customrequestattribute_add_integers_p(
        keys: *const onesdk_string_t,
        values: *const onesdk_int64_t,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_customrequestattribute_add_floats_p(
        keys: *const onesdk_string_t,
        values: *const f64,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_customrequestattribute_add_strings_p(
        keys: *const onesdk_string_t,
        values: *const onesdk_string_t,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @brief Creates an in-process link."]
    #[doc = "@param[out] buffer                  [optional] Pointer to a buffer into which the in-process link shall be copied."]
    #[doc = "@param buffer_size                  Size of the buffer pointed to by @p buffer in bytes. Must be zero if @p buffer is `NULL`."]
    #[doc = "@param[out] required_buffer_size    [optional] Pointer to a @ref onesdk_size_t variable where the required buffer size will be stored."]
    #[doc = ""]
    #[doc = "@return The number of bytes copied into @p buffer."]
    #[doc = ""]
    #[doc = "An application can call this function to retrieve an in-process link, which can then be used to trace related processing at a later"]
    #[doc = "time and/or in a different thread."]
    #[doc = ""]
    #[doc = "If @p required_buffer_size is not `NULL`, the number of bytes required to store the in-process link is stored in"]
    #[doc = "@p *required_buffer_size."]
    #[doc = ""]
    #[doc = "If @p buffer is not `NULL` and @p buffer_size is big enough, this function will copy the in-process link into the provided buffer."]
    #[doc = ""]
    #[doc = "@note If no tracer is active on the current thread, the retrieved link will be empty (have zero length)."]
    #[doc = "@note Links returned by this function are not compatible with dynatrace string or byte tags, they can only be used with"]
    #[doc = "@ref onesdk_inprocesslinktracer_create."]
    #[doc = "@note Links returned by this function can only be used in the process in which they were created."]
    #[doc = ""]
    #[doc = "For more information see @ref in_process_links."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.2.0."]
    pub fn onesdk_inprocesslink_create(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: onesdk_size_t,
        required_buffer_size: *mut onesdk_size_t,
    ) -> onesdk_size_t;
}
extern "C" {
    #[doc = " @brief Creates a tracer for tracing asynchronous related processing in the same process."]
    #[doc = "@param in_process_link         Pointer to an array that holds the in-process link."]
    #[doc = "@param in_process_link_size    Size of the in-process link."]
    #[doc = ""]
    #[doc = "@return A handle for the newly created in-process link tracer or @ref ONESDK_INVALID_HANDLE."]
    #[doc = ""]
    #[doc = "@note If the provided in-process link is empty or invalid, no tracer will be created and this function will return"]
    #[doc = "@ref ONESDK_INVALID_HANDLE."]
    #[doc = ""]
    #[doc = "For more information see @ref in_process_links."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.2.0."]
    pub fn onesdk_inprocesslinktracer_create(
        in_process_link: *const ::std::os::raw::c_uchar,
        in_process_link_size: onesdk_size_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_outgoingremotecalltracer_create_p(
        service_method: *const onesdk_string_t,
        service_name: *const onesdk_string_t,
        service_endpoint: *const onesdk_string_t,
        channel_type: onesdk_int32_t,
        channel_endpoint: *const onesdk_string_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_outgoingremotecalltracer_set_protocol_name_p(
        tracer_handle: onesdk_tracer_handle_t,
        protocol_name: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingremotecalltracer_create_p(
        service_method: *const onesdk_string_t,
        service_name: *const onesdk_string_t,
        service_endpoint: *const onesdk_string_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingremotecalltracer_set_protocol_name_p(
        tracer_handle: onesdk_tracer_handle_t,
        protocol_name: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_databaseinfo_create_p(
        name: *const onesdk_string_t,
        vendor: *const onesdk_string_t,
        channel_type: onesdk_int32_t,
        channel_endpoint: *const onesdk_string_t,
    ) -> onesdk_databaseinfo_handle_t;
}
extern "C" {
    #[doc = " @brief Releases a database info object."]
    #[doc = "@param databaseinfo_handle      A valid database info handle."]
    #[doc = ""]
    #[doc = "This function releases the specified database info object. Allocated resources are freed and the handle is invalidated."]
    #[doc = ""]
    #[doc = "An application should call @ref onesdk_databaseinfo_delete exactly once for each database info object that it has created."]
    #[doc = ""]
    #[doc = "@note Calling @ref onesdk_databaseinfo_delete with a handle to a database info object which is still referenced by existing tracers is"]
    #[doc = "supported. In that case the lifetime of the database info object is extended as necessary. The handle will always become invalid"]
    #[doc = "immediately though."]
    pub fn onesdk_databaseinfo_delete(databaseinfo_handle: onesdk_databaseinfo_handle_t);
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_databaserequesttracer_create_sql_p(
        databaseinfo_handle: onesdk_databaseinfo_handle_t,
        statement: *const onesdk_string_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @brief Sets the number of returned rows for a database request."]
    #[doc = "@param tracer_handle            A valid database request tracer handle."]
    #[doc = "@param returned_row_count       The number of returned rows. Must be >= 0."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.1.0."]
    pub fn onesdk_databaserequesttracer_set_returned_row_count(
        tracer_handle: onesdk_tracer_handle_t,
        returned_row_count: onesdk_int32_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the number of round trips for a database request."]
    #[doc = "@param tracer_handle            A valid database request tracer handle."]
    #[doc = "@param round_trip_count         The number of round trips between the client and the database. Must be >= 0."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.1.0."]
    pub fn onesdk_databaserequesttracer_set_round_trip_count(
        tracer_handle: onesdk_tracer_handle_t,
        round_trip_count: onesdk_int32_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_webapplicationinfo_create_p(
        web_server_name: *const onesdk_string_t,
        application_id: *const onesdk_string_t,
        context_root: *const onesdk_string_t,
    ) -> onesdk_webapplicationinfo_handle_t;
}
extern "C" {
    #[doc = " @brief Releases a web application info object."]
    #[doc = "@param webapplicationinfo_handle    A valid web application info handle."]
    #[doc = ""]
    #[doc = "This function releases the specified web application info object. Allocated resources are freed and the handle is invalidated."]
    #[doc = ""]
    #[doc = "An application should call @ref onesdk_webapplicationinfo_delete exactly once for each web application info object that it has created."]
    #[doc = ""]
    #[doc = "@note Calling @ref onesdk_webapplicationinfo_delete with a handle to a web application info object which is still referenced by existing"]
    #[doc = "tracers is supported. In that case the lifetime of the web application info object is extended as necessary. The handle will"]
    #[doc = "always become invalid immediately though."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.1.0."]
    pub fn onesdk_webapplicationinfo_delete(
        webapplicationinfo_handle: onesdk_webapplicationinfo_handle_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingwebrequesttracer_create_p(
        webapplicationinfo_handle: onesdk_webapplicationinfo_handle_t,
        url: *const onesdk_string_t,
        method: *const onesdk_string_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingwebrequesttracer_set_remote_address_p(
        tracer_handle: onesdk_tracer_handle_t,
        remote_address: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingwebrequesttracer_add_request_headers_p(
        tracer_handle: onesdk_tracer_handle_t,
        names: *const onesdk_string_t,
        values: *const onesdk_string_t,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingwebrequesttracer_add_parameters_p(
        tracer_handle: onesdk_tracer_handle_t,
        names: *const onesdk_string_t,
        values: *const onesdk_string_t,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingwebrequesttracer_add_response_headers_p(
        tracer_handle: onesdk_tracer_handle_t,
        names: *const onesdk_string_t,
        values: *const onesdk_string_t,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the HTTP status code for an incoming web request."]
    #[doc = "@param tracer_handle            A valid incoming web request tracer handle."]
    #[doc = "@param status_code              The HTTP status code of the response sent to the client."]
    #[doc = ""]
    #[doc = "@note If an application can not send a response to the client, it should @em not call this function. Instead the application can use"]
    #[doc = "@ref onesdk_tracer_error to signal that the request could not be processed successfully."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.1.0."]
    pub fn onesdk_incomingwebrequesttracer_set_status_code(
        tracer_handle: onesdk_tracer_handle_t,
        status_code: onesdk_int32_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_outgoingwebrequesttracer_create_p(
        url: *const onesdk_string_t,
        method: *const onesdk_string_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_outgoingwebrequesttracer_add_request_headers_p(
        tracer_handle: onesdk_tracer_handle_t,
        names: *const onesdk_string_t,
        values: *const onesdk_string_t,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_outgoingwebrequesttracer_add_response_headers_p(
        tracer_handle: onesdk_tracer_handle_t,
        names: *const onesdk_string_t,
        values: *const onesdk_string_t,
        count: onesdk_size_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the HTTP status code for an outgoing web request."]
    #[doc = "@param tracer_handle            A valid outgoing web request tracer handle."]
    #[doc = "@param status_code              The HTTP status code of the response that was received."]
    #[doc = ""]
    #[doc = "@note If an application fails to receive or decode the reply, it should @em not call this function. Instead the application can use"]
    #[doc = "@ref onesdk_tracer_error to signal that the request was not completed successfully."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.2.0."]
    pub fn onesdk_outgoingwebrequesttracer_set_status_code(
        tracer_handle: onesdk_tracer_handle_t,
        status_code: onesdk_int32_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_customservicetracer_create_p(
        service_method: *const onesdk_string_t,
        service_name: *const onesdk_string_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_messagingsysteminfo_create_p(
        vendor_name: *const onesdk_string_t,
        destination_name: *const onesdk_string_t,
        destination_type: onesdk_int32_t,
        channel_type: onesdk_int32_t,
        channel_endpoint: *const onesdk_string_t,
    ) -> onesdk_messagingsysteminfo_handle_t;
}
extern "C" {
    #[doc = " @brief Releases a messaging system info object."]
    #[doc = "@param messagingsysteminfo_handle   A valid messaging system info handle."]
    #[doc = ""]
    #[doc = "This function releases the specified messaging system info object. Allocated resources are freed and the handle is invalidated."]
    #[doc = ""]
    #[doc = "An application should call @ref onesdk_messagingsysteminfo_delete exactly once for each messaging system info object that it has created."]
    #[doc = ""]
    #[doc = "@note Calling @ref onesdk_messagingsysteminfo_delete with a handle to a messaging system info object which is still referenced by existing"]
    #[doc = "tracers is supported. In that case the lifetime of the messaging system info object is extended as necessary. The handle will"]
    #[doc = "always become invalid immediately though."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.4.0."]
    pub fn onesdk_messagingsysteminfo_delete(
        messagingsysteminfo_handle: onesdk_messagingsysteminfo_handle_t,
    );
}
extern "C" {
    #[doc = " @brief Creates a tracer for tracing an outgoing message."]
    #[doc = "@param messagingsysteminfo_handle   A valid messaging system info handle."]
    #[doc = ""]
    #[doc = "@return A handle for the newly created outgoing message tracer or @ref ONESDK_INVALID_HANDLE."]
    #[doc = ""]
    #[doc = "@since This function was added in version 1.4.0."]
    pub fn onesdk_outgoingmessagetracer_create(
        messagingsysteminfo_handle: onesdk_messagingsysteminfo_handle_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_outgoingmessagetracer_set_vendor_message_id_p(
        tracer_handle: onesdk_tracer_handle_t,
        vendor_message_id: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_outgoingmessagetracer_set_correlation_id_p(
        tracer_handle: onesdk_tracer_handle_t,
        correlation_id: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @brief Creates a tracer for tracing the receipt of an incoming message."]
    #[doc = "@param messagingsysteminfo_handle   A valid messaging system info handle."]
    #[doc = ""]
    #[doc = "@return A handle for the newly created incoming message receive tracer or @ref ONESDK_INVALID_HANDLE."]
    #[doc = ""]
    #[doc = "Tracing the receipt of the message is optional but may make sense if receiving may take a significant amount of time,"]
    #[doc = "e.g. when doing a blocking receive. It might make less sense when tracing a polling receive. If you do use a receive"]
    #[doc = "tracer, start and end the corresponding incoming message process tracer while the receive tracer is still active."]
    #[doc = ""]
    #[doc = "@see onesdk_incomingmessageprocesstracer_create"]
    #[doc = "@since This function was added in version 1.4.0."]
    pub fn onesdk_incomingmessagereceivetracer_create(
        messagingsysteminfo_handle: onesdk_messagingsysteminfo_handle_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @brief Creates a tracer for tracing the processing of an incoming message."]
    #[doc = "@param messagingsysteminfo_handle   A valid messaging system info handle."]
    #[doc = ""]
    #[doc = "@return A handle for the newly created incoming message process tracer or @ref ONESDK_INVALID_HANDLE."]
    #[doc = ""]
    #[doc = "Use this tracer to trace the actual, logical processing of the message as opposed to the time it takes to receive it."]
    #[doc = ""]
    #[doc = "If you use an incoming message receive tracer to trace the receipt of the processed message, start"]
    #[doc = "and end the corresponding incoming message process tracer while the receive tracer is still active."]
    #[doc = ""]
    #[doc = "@see onesdk_incomingmessagereceivetracer_create"]
    #[doc = "@since This function was added in version 1.4.0."]
    pub fn onesdk_incomingmessageprocesstracer_create(
        messagingsysteminfo_handle: onesdk_messagingsysteminfo_handle_t,
    ) -> onesdk_tracer_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingmessageprocesstracer_set_vendor_message_id_p(
        tracer_handle: onesdk_tracer_handle_t,
        vendor_message_id: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_incomingmessageprocesstracer_set_correlation_id_p(
        tracer_handle: onesdk_tracer_handle_t,
        correlation_id: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @brief Releases a metric object."]
    #[doc = "@param metric_handle      A valid metric handle (all types are supported)."]
    #[doc = ""]
    #[doc = "This function releases the specified metric object. Allocated resources are freed and the handle is invalidated."]
    #[doc = ""]
    #[doc = "An application should call @ref onesdk_metric_delete exactly once for each metric object that it has created."]
    pub fn onesdk_metric_delete(metric_handle: onesdk_metric_handle_t);
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_integercountermetric_create_p(
        metric_key: *const onesdk_string_t,
        unit: *const onesdk_string_t,
        dimension_name: *const onesdk_string_t,
    ) -> onesdk_metric_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_floatcountermetric_create_p(
        metric_key: *const onesdk_string_t,
        unit: *const onesdk_string_t,
        dimension_name: *const onesdk_string_t,
    ) -> onesdk_metric_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_integergaugemetric_create_p(
        metric_key: *const onesdk_string_t,
        unit: *const onesdk_string_t,
        dimension_name: *const onesdk_string_t,
    ) -> onesdk_metric_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_floatgaugemetric_create_p(
        metric_key: *const onesdk_string_t,
        unit: *const onesdk_string_t,
        dimension_name: *const onesdk_string_t,
    ) -> onesdk_metric_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_integerstatisticsmetric_create_p(
        metric_key: *const onesdk_string_t,
        unit: *const onesdk_string_t,
        dimension_name: *const onesdk_string_t,
    ) -> onesdk_metric_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_floatstatisticsmetric_create_p(
        metric_key: *const onesdk_string_t,
        unit: *const onesdk_string_t,
        dimension_name: *const onesdk_string_t,
    ) -> onesdk_metric_handle_t;
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_integercountermetric_increase_by_p(
        metric_handle: onesdk_metric_handle_t,
        delta: onesdk_int64_t,
        dimension: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_floatcountermetric_increase_by_p(
        metric_handle: onesdk_metric_handle_t,
        delta: f64,
        dimension: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_integergaugemetric_set_value_p(
        metric_handle: onesdk_metric_handle_t,
        value: onesdk_int64_t,
        dimension: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_floatgaugemetric_set_value_p(
        metric_handle: onesdk_metric_handle_t,
        value: f64,
        dimension: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_integerstatisticsmetric_add_value_p(
        metric_handle: onesdk_metric_handle_t,
        value: onesdk_int64_t,
        dimension: *const onesdk_string_t,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn onesdk_floatstatisticsmetric_add_value_p(
        metric_handle: onesdk_metric_handle_t,
        value: f64,
        dimension: *const onesdk_string_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
